<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <script>
        // Написать функцию createDebounceFunction.Она должна принимать два аргумента: callback -
        //     функцию и задержку в миллисекундах.
        // Данная функция должна возвращать новую функцию, вызывающую callback -
        //     функцию с задержкой в переданное количество миллисекунд.
        // ПРИ ЭТОМ!Если за то время, пока внутрення callback - функция ждёт своего вызова,
        //     наша созданная функция вызывается ещё раз, то "счётчик"
        // времени должен сбрасываться и начинаться заново(т.е.вызова внутренней функции произойти не должно).

        //     >
        //     Пример:
        //     const log100 = () => console.log(100);
        // const debounceLog100 = createDebounceFunction(log100, 1000);
        // debounceLog100();
        // setTimeout(debounceLog100,
        // 200); // так как задержка в 1000мс и новый вызов этой же функции происходит через 200 миллисекунд, то таймер запускается заново
        // setTimeout(debounceLog100, 400); // снова сбрасываем таймер ещё через 200 миллисекунд

        // Вывод в консоли значения 100 примерно через 1000 мс + 200 мс + 200 мс

        function createDebounceFunction(callback, time) {
            return () => setTimeout(callback, time)

        }

        const log100 = () => console.log(100);
        const debounceLog100 = createDebounceFunction(log100, 1000);
        debounceLog100();
        // setTimeout(debounceLog100, 200); // так как задержка в 1000мс и новый вызов этой же функции происходит через 200 миллисекунд, то таймер запускается заново
        // setTimeout(debounceLog100, 400); // снова сбрасываем таймер ещё через 200 миллисекунд
    </script>
</body>

</html>